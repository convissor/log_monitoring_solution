#! /usr/bin/perl -w
use strict;


# >>> TEST BED VERSION <<<
#
# >>> Pass username (for the "To" email address) as a parameter.  <<


# Watches the log file of your chosing in real time for any matches against
# the regular expression you provide and notifies you of them via email.
#
# Keeps track of duplicate messages and sends the resulting count of them at
# intervals, rather than clogging inboxes with one email per error.
#
# Gracefully handles situations where the log file doesn't exist yet or
# gets rotated.
#
# Comes pre-configured to monitor fatal and parse errors generated by
# PHP scripts.
#
#
# This script and log_monitoring_solution_runner.pl must be in the same
# directory.  We suggest /usr/local/bin.
#
# This script is started and managed by log_monitoring_solution_runner.sh.
# That shell script must be executed by a cron job on a regular basis.
# See log_monitoring_solution_crontab.txt for an example.
#
#
# http://www.analysisandsolutions.com/software/log_monitoring_solution/
# http://github.com/convissor/log_monitoring_solution
#
# Author: Daniel Convissor <danielc@analysisandsolutions.com>
# License: http://www.analysisandsolutions.com/software/license.htm Simple Public License
# Copyright: The Analysis and Solutions Company, 2010


# ===== SETTINGS =====
my $file = 't.txt';

# Case-insensitive regular expression to check each line against.
my $regex = 'PHP (Fatal|Parse) error: (.*)';
# The $regex substring to use for tracking duplicate messages.
my $substr_digit = 2;

my $mail_subject = 'PHP FATAL ERROR';
my $mail_to = $ARGV[0] . '@localhost';
my $mail_from = 'root@localhost';
# Leave this alone unless you know what you're doing.
my $mail_cmd = "/usr/sbin/sendmail -f $mail_from $mail_to";

# The number of seconds to spend sleeping between reads.
my $interval = 1;
# The number of minutes until renotification of duplicate error messages.
my $throttle = 2/60;
# ====================


# Obtain required packages.
use Digest::MD5 qw(md5_hex);
use Sys::Hostname;


# Declare global variables.
my $fh;
my $initial_inode = 0;
my $seek = 1;  # Start from end of file.
my $curpos = 0;
my $md5 = '';
my %sent = ();
my $host = hostname();


# Opens $file.
# If the initial file was moved, any remaining data extracted from it.
# If the file doesn't exist yet, sleep for $interval, then check again.
# Returns 1 when the file exists.
sub open_file {
    if (defined($fh)) {
        # A log file was already opened.  It probably got moved.
        if ((stat($fh))[7]) {
            # It still has content, which we shall read
            # before trying to access the new file.
            read_file();
        }
        close($fh);
        reset 'fh';
        $curpos = 0;
    }

    for (;;) {
        if (-e $file) {
            open($fh, $file) or die send_error("log_monitoring_solution.pl "
                    . "couldn't open $file: $!", 0, 0);
            $initial_inode = (stat($fh))[1];
            return 1;
        }
        # File doesn't exist yet.

        # Once it does, get all data in it, don't seek() the end of the file.
        $seek = 0;

        # Wait a while before checking for the file again.
        sleep($interval);
    }
}

# Reads lines from $fh, looking for matches against $regex.
# Creates an md5 of the $substr_digit'th returned by $regex and uses that as
#   a key for %sent.
# If the md5 doesn't exist, sends an email right away.
# If the md5 exists and the prior email was sent more than $throttle minutes
#   ago, sends another email now saying how many times the error happend
#   since the last email.
sub read_file {
    for ($curpos = tell($fh); $_ = <$fh>; $curpos = tell($fh)) {
        if ( m/$regex/i ) {
            no strict 'refs';  # To enable substr_digit reference.
            $md5 = md5_hex $$substr_digit;

            if (exists $sent{$md5}) {
                if ((time() - $sent{$md5}{'time'}) > ($throttle * 60)) {
                    send_error($_, $sent{$md5}{'count'}, $sent{$md5}{'time'});
                    $sent{$md5}{'time'} = time();
                    $sent{$md5}{'count'} = 0;
                }
                $sent{$md5}{'count'}++;
            } else {
                $sent{$md5}{'time'} = time();
                $sent{$md5}{'count'} = 1;
                send_error($_, $sent{$md5}{'count'}, $sent{$md5}{'time'});
            }
        }
    }
}

# Composes and submits the email messages.
sub send_error {
    my ($body, $count, $time) = @_;

    open(MAIL, "|$mail_cmd") or die "Can't open $mail_cmd: $!";
    print MAIL "To: $mail_to\n";
    print MAIL "Subject: $mail_subject\n";
    print MAIL "Content-type: text/plain\n\n";

    print MAIL "Host: $host\n";
    print MAIL "Error Log: $file\n\n";
    if ($count > 1) {
        my $mins = int((time() - $time) / 60);
        print MAIL "The following error happened $count times in the "
                . "past $mins minutes.\n\n";
    }
    print MAIL $body;

    close(MAIL) or die "Problem closing MAIL: $!";
}


# Get down to business...
open_file();
if ($seek) {
    # Jump to the end of the file.
    seek($fh, -s $file, 0);
}

for (;;) {
    if (! -e $file
        || $initial_inode != (stat($file))[1]
        || $curpos > (stat($file))[7] )
    {
        # The initial file has been removed, renamed or truncated.
        open_file();
    }

    read_file();

    sleep($interval);
    seek($fh, $curpos, 0);
}
