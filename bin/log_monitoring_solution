#! /usr/bin/perl -w
use strict;
use warnings;

# Watches the log file of your choosing in real time for any matches against
# the regular expression you provide and notifies you of them via email.
#
# Keeps track of duplicate messages and sends the resulting count of them at
# intervals, rather than clogging inboxes with one email per error.
#
# Gracefully handles situations where the log file doesn't exist yet or
# gets rotated.
#
# Comes pre-configured to monitor fatal and parse errors generated by
# PHP scripts.
#
# Start this script using the script provided in init.d.
#
#
# Author: Daniel Convissor <danielc@analysisandsolutions.com>
# License: http://www.analysisandsolutions.com/software/license.htm Simple Public License
# Copyright: The Analysis and Solutions Company, 2010
#
# http://www.analysisandsolutions.com/software/log_monitoring_solution/
# http://github.com/convissor/log_monitoring_solution


# ===== SETTINGS =====
# Case-insensitive regular expression to check each line against.
my $regex = 'PHP (Fatal|Parse) error: (.*)';

# The id of the subpattern in $regex that contains the specific error
# message.  Used for tracking duplicate messages.
my $details_subpattern_id = 2;

# Log file for output from this daemon.
my $local_log = '/var/log/log_monitoring_solution.log';

my $mail_subject = 'PHP FATAL ERROR';
my $mail_to = 'root@localhost';
my $mail_from = 'root@localhost';

# Leave this alone unless you know what you're doing.
my @mail_cmd = ('/usr/sbin/sendmail', '-f', $mail_from, $mail_to);

# The number of seconds to spend sleeping between reads.
my $interval = 60;

# The number of minutes until re-notification of duplicate error messages.
my $throttle = 60;
# ====================


# Obtain required packages.
use Date::Format;
use Digest::MD5 'md5_hex';
use Getopt::Long;
use IO::File;
use POSIX 'setsid';
use POSIX 'WNOHANG';
use Sys::Hostname;
use Sys::Syslog;

# Declare global variables.
my $curpos = 0;
my $fh_php_log;
my $host = hostname();
my $initial_inode = 0;
my $md5 = '';
my $php_log;
my $pid = 0;
my $pid_file;
my $seek = 1;  # Start from end of file.
my %sent = ();

# Ignore exiting child events.
$SIG{CHLD} = sub { while (waitpid(-1,WNOHANG)>0) { } };

# Grab termination and interrupt signals so we can remove pid file.
$SIG{TERM} = $SIG{INT} = sub {
	log_local('Received SIGTERM or SIGINT');
	exit 0;
};


#
# Get down to business...
#

log_local('Starting');

# Obtain command line arguments.
GetOptions('l=s' => \$php_log, 'p=s' => \$pid_file);
if (!$php_log || !$pid_file) {
	log_die('Usage: log_monitoring_solution.pl -l <php_log> -p <pid_file>');
}

# Prevent duplicate processes.
my $fh_pid = open_pid_file($pid_file);

# Daemonize.
$pid = become_daemon();

# Write child PID to a file then close that file.
print $fh_pid $pid;
close($fh_pid);

log_local('Daemonized and created PID file');

open_file();
if ($seek) {
	# Jump to the end of the file.
	seek($fh_php_log, -s $php_log, 0);
}

while (1) {
	if (! -e $php_log
		|| $initial_inode != (stat($php_log))[1]
		|| $curpos > (stat($php_log))[7] )
	{
		# The initial file has been removed, renamed or truncated.
		open_file();
	}

	read_file();

	sleep($interval);
	seek($fh_php_log, $curpos, 0);
}


#
# Function declarations.
#

# Daemonizes the current process.
#
# Returns id of child process.
#
# Inspired by examples in "Network Programming with Perl" by Lincoln Stein.
sub become_daemon {
	log_die("Problem forking: $!") unless defined (my $child = fork);

	if ($child) {
		log_local('Child spawned; parent exiting');
		exit 0;
	}

	log_local('Continue daemonizing child');

	# Become session leader.
	setsid();

	# Close handles.
	open(STDIN, '<', '/dev/null');
	open(STDOUT, '>', '/dev/null');
	open(STDERR, '>', '/dev/null');

	chdir '/';
	umask(0);
	$ENV{PATH} = '/bin:/sbin:/usr/bin:/usr/sbin';
	return $$;
}

# Passes the given message to log_local and die.
#
# Parameter: string $message  the message to log
sub log_die {
	my ($message) = @_;
	log_local("DIE: $message");
	die $message;
}

# Puts the given message in $local_log.
#
# Parameter: string $message  the message to log
sub log_local {
	my ($message) = @_;
	open(my $fh_daemon_log, '>>', $local_log)
		or die log_system("Problem opening $local_log: $!");
	print $fh_daemon_log time2str('%h %e %X ', time) . $host
		. "[" . $$ . "]: $message\n";
	close($fh_daemon_log) or die log_system("Problem closing $local_log: $!");
}

# Puts the given message in syslog.
#
# Parameter: string $message  the message to log
sub log_system {
	my ($message) = @_;
	openlog('log_monitoring_solution', 'ndelay,pid', 'local0');
	syslog(Sys::Syslog::LOG_ERR, $message);
	closelog();
}

# Opens the $php_log file.
#
# If the initial file was moved, any remaining data extracted from it.
#
# If the file doesn't exist yet, sleep for $interval, then check again.
#
# Returns 1 when the file exists.
sub open_file {
	if (defined($fh_php_log)) {
		log_local('The log file was already opened, it probably got moved');
		if ((stat($fh_php_log))[7]) {
			log_local('Reading remaining content from old file.');
			read_file();
		}
		close($fh_php_log);
		reset 'fh_php_log';
		$curpos = 0;
	}

	my $checked = 0;
	while (1) {
		if (-e $php_log) {
			open($fh_php_log, $php_log) or log_die(
				"Problem opening $php_log: $!");
			$initial_inode = (stat($fh_php_log))[1];
			log_local("Opened $php_log for monitoring");
			return 1;
		}
		# File doesn't exist yet.

		if (!$checked) {
			log_local("$php_log does not exist yet, will wait for it");
			$checked = 1;
		}

		# Once it does, get all data in it, don't seek() the end of the file.
		$seek = 0;

		# Wait a while before checking for the file again.
		sleep($interval);
	}
}

# Manages the PID file and prevents duplicate instances of this script.
#
# If $pid_file exists, check the PID in it against running processes.
# Exit if the process indicated by PID is running fine.
# Removes $pid_file if the indicated process is dead, then continues...
#
# Creates $pid_file if it no longer exists.
#
# Returns handle to the PID file.
#
# Inspired by examples in "Network Programming with Perl" by Lincoln Stein.
sub open_pid_file {
	my $fh;

	if (-e $pid_file) {
		# File already exists.

		$fh = IO::File->new($pid_file);
		if (!$fh) {
			log_die("Problem opening $pid_file: $!");
		}

		my $pid = <$fh>;
		if (kill 0 => $pid) {
			log_local("Daemon already running with PID $pid");
			exit 1;
		}

		unless (-w $pid_file && unlink $pid_file) {
			log_die("Problem removing defunct PID file for $pid ($pid_file): $!");
		} else {
			log_local("Removing defunct PID file for $pid");
		}
	}

	$fh = IO::File->new($pid_file, O_WRONLY|O_CREAT|O_EXCL, 0644);
	if (!$fh) {
		log_die("Problem creating $pid_file: $!");
	}
	return $fh;
}

# Reads lines from $fh_php_log, looking for matches against $regex.
#
# Creates an md5 of the $details_subpattern_id'th returned by $regex and uses
# that as a key for %sent.
#
# If the md5 doesn't exist, sends an email right away.
#
# If the md5 exists and the prior email was sent more than $throttle minutes
# ago, sends another email now saying how many times the error happened
# since the last email.
sub read_file {
	# Enable variable variables for details_subpattern_id.
	no strict 'refs';

	for ($curpos = tell($fh_php_log); $_ = <$fh_php_log>; $curpos = tell($fh_php_log)) {
		if ( m/$regex/i ) {
			$md5 = md5_hex $$details_subpattern_id;

			if (exists $sent{$md5}) {
				if ((time() - $sent{$md5}{'time'}) > ($throttle * 60)) {
					send_mail($_, $sent{$md5}{'count'}, $sent{$md5}{'time'});
					$sent{$md5}{'time'} = time();
					$sent{$md5}{'count'} = 0;
				}
				$sent{$md5}{'count'}++;
			} else {
				$sent{$md5}{'time'} = time();
				$sent{$md5}{'count'} = 1;
				send_mail($_, $sent{$md5}{'count'}, $sent{$md5}{'time'});
			}
		}
	}
}

# Composes and submits the email messages.
#
# Parameter: string $body  the message to be sent
# Parameter: int $count  the number of message occurrences since last sending
# Parameter: int $time  the unix timestamp for when this message was last sent
sub send_mail {
	my ($body, $count, $time) = @_;

	open(my $fh_mail, '|-', @mail_cmd)
		or die log_die("Problem opening @mail_cmd: $!");
	print $fh_mail "To: $mail_to\n";
	print $fh_mail "Subject: $mail_subject\n";
	print $fh_mail "Content-type: text/plain\n\n";

	print $fh_mail "Host: $host\n";
	print $fh_mail "Error Log: $php_log\n\n";
	if ($count > 1) {
		my $mins = int((time() - $time) / 60);
		print $fh_mail "The following error happened $count times in the "
				. "past $mins minutes.\n\n";
	}
	print $fh_mail $body;

	close($fh_mail) or die log_die("Problem closing fh_mail: $!");

	log_local('Mail sent');
}

# Handle script exits.
END {
	if ($$ == $pid) {
		if (-e $pid_file) {
			if (unlink $pid_file) {
				log_local('Removed PID file');
			} else {
				log_local("Problem removing $pid_file: $!");
			}
		} else {
			log_local("$pid_file does not exist");
		}
		log_local('Stopping');
	}
}
